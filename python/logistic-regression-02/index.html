<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      ロジスティック回帰 -その2- &middot; cpp-python-beginners
    
  </title>

  
  <link rel="canonical" href="https://tatsy.github.io/cpp-python-beginners/python/logistic-regression-02/">
  

  <link rel="stylesheet" href="https://tatsy.github.io/cpp-python-beginners/public/css/poole.css">
  <link rel="stylesheet" href="https://tatsy.github.io/cpp-python-beginners/public/css/syntax.css">
  <link rel="stylesheet" href="https://tatsy.github.io/cpp-python-beginners/public/css/lanyon.css">
  <link rel="stylesheet" href="https://tatsy.github.io/cpp-python-beginners/public/css/main.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">

  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://tatsy.github.io/cpp-python-beginners/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="https://tatsy.github.io/cpp-python-beginners/public/favicon.ico">
  <link rel="alternate" type="application/rss+xml" title="RSS" href="https://tatsy.github.io/cpp-python-beginners/atom.xml">

  <script type="text/javascript" src="/cpp-python-beginners/public/js/jquery.min.js"></script>
  <script type="text/javascript" src="/cpp-python-beginners/public/js/lightbox.min.js"></script><script>
MathJax = {
    tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        processEscapes: true,
        tags: "ams",
        autoload: {
            color: [],
            colorV2: ['color']
        },
        packages: {'[+]': ['noerrors']}
    },
    chtml: {
        scale: 1.1,
        matchFontHeight: false,
        displayAlign: "left",
        displayIndent: "2em"
    },
    options: {
        renderActions: {
            /* add a new named action to render <script type="math/tex"> */
            find_script_mathtex: [10, function (doc) {
            for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = {node: text, delim: '', n: 0};
                math.end = {node: text, delim: '', n: 0};
                doc.math.push(math);
            }
            }, '']
        }
    },
    loader: {
        load: ['[tex]/noerrors']
    }
};
</script>
<script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js" id="MathJax-script"></script>
</head>


  <body>

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
    styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p>初心者向けC++/Pythonプログラミング</p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item" href="https://tatsy.github.io/cpp-python-beginners/">Home</a>

    

    
    
      
        
      
    
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
          <a class="sidebar-nav-item" href="https://tatsy.github.io/cpp-python-beginners/cpp/">C++プログラミング</a>
        
      
    
      
    
      
    
      
        
          <a class="sidebar-nav-item" href="https://tatsy.github.io/cpp-python-beginners/python/">Pythonプログラミング</a>
        
      
    

    <a class="sidebar-nav-item" href="https://github.com/tatsy/cpp-python-beginners">GitHub project</a>
    <span class="sidebar-nav-item">Currently v1.0.0</span>
  </nav>

  <div class="sidebar-item">
    <p>
      &copy; 2020. All rights reserved.
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/cpp-python-beginners/" title="Home">cpp-python-beginners</a>
            <small>Programming for everyone!</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="post">
  <h1 class="post-title">ロジスティック回帰 -その2-</h1>
  <h2 id="ロジスティック回帰の理論">ロジスティック回帰の理論</h2>

<p><a href="/cpp-python-beginners/_python/logistic-regression-01/">ロジスティック回帰 -その1-</a>で述べた通り、ロジスティック回帰による識別モデルは、線形変換とsoftmax関数の組み合わせである。softmax関数にはパラメータ変数は含まれないので、回帰モデル自体のパラメータは行列 $\mathbf{A}$ とバイアスベクトル $\mathbf{b}$ のみである。</p>

<p>従って、これらのパラメータを、より損失関数が小さくなるように最適化することが、上記のロジスティック回帰の目的となる。</p>

<h3 id="損失関数">損失関数</h3>

<p>今、学習データに含まれる画像データを $\mathbf{x}$, ラベルのデータを $\mathbf{y}$ とする。すると、とある パラメータ$\mathbf{A}, \mathbf{b}$を用いたデータからの予測値 $\tilde{\mathbf{y}}$は、</p>

\[\tilde{\mathbf{y}} = \sigma(\mathbf{Ax} + \mathbf{b})\]

<p>となるのであった(簡単のためにsoftmax関数を$\sigma$とした)。この予測値が実際の学習データに含まれる真値にどれくらい近いかを計るとすれば、もっとも単純なものはL2ノルムを使うものだろう。</p>

\[L_2(\mathbf{y}, \tilde{\mathbf{y}}) = \| \mathbf{y} - \tilde{\mathbf{y}} \|^2\]

<p>ここでは損失の測り方をL2ノルムとしたが、当然ながら、その他の測り方も可能である。一般にロジスティック回帰においては交差エントロピー (cross entropy) がよく用いられる。交差エントロピーはベクトルの次元を $D$として以下のように書ける。</p>

\[L_{CE}(\mathbf{y}, \tilde{\mathbf{y}}) = \sum_{d=1}^D -y_d \log \tilde{y}_d\]

<p>ただし、問題が二者識別問題でsoftmax関数の代わりにsigmoid関数が使われる場合には、上記の代わりに以下のバイナリ交差エントロピー (binary cross entropy) が用いられる。</p>

\[L_{BCE}(\mathbf{y}, \tilde{\mathbf{y}}) = \sum_{d=1}^D \left[ -y_d \log \tilde{y}_d - (1 - y_d) \log (1 - \tilde{y}_d) \right]\]

<p>交差エントロピーはL2ノルムなどと比べ、誤差が大きい場合により強く誤差がかかるようになっている。通常、学習データに含まれるラベルは$[0, 1, 0, 0, \ldots, 0]$のような一つだけが1になっているベクトル(この形式をone-hot形式という)だから、仮に$y_j=1$であるとすれば、交差エントロピーと、その微分は以下のようになる。</p>

\[\begin{aligned}
    L &amp;= \begin{cases}
    -\log \tilde{y}_j &amp; (i = j) \\
    0 &amp; \text{otherwise}
    \end{cases} \\

    \frac{\partial L}{\partial \tilde{y}_i} &amp;= \begin{cases}
    -\frac{1}{\tilde{y}_j} &amp; (i = j) \\
    0 &amp; \text{otherwise}
    \end{cases}
\end{aligned}\]

<p>このように、$\tilde{y}_j$が欲しい真値(=1)と遠い0を取ろうとすると、勾配が無限に大きな値を取ることが分かる。一般に上記のような損失関数は勾配情報を使った最小化アルゴリズム(最急降下法やニュートン法)を用いて最適化されるため、どのような勾配が得られるかはとても重要だ。</p>

<p>ただし、交差エントロピーは確率的な出力 (上記の例ではベクトルの要素の合計が1になる) 場合にしか使えないので気をつけること。</p>

<h3 id="チェインルール">チェイン・ルール</h3>

<p>ロジスティック回帰をはじめとして、現在の深層学習を含むニューラルネットワークの理論には合成関数の微分に使われる「チェイン・ルール」が非常に重要な概念となる。これが、ニューラルネットワークの理論を支える重要な発見の一つである「誤差逆伝搬法(backpropagation)」の基礎となる。</p>

<p>今、損失関数$L$を簡単のために$\mathbf{A}$の関数だとみなそう。$A$は最初の$\tilde{\mathbf{y}}$を計算するのに使われている。その意味では$\tilde{\mathbf{y}}$も$\mathbf{A}$の関数だ。また$\mathbf{t} = \mathbf{Ax} + \mathbf{b}$のように書くこととすると、損失関数は合成関数として以下のように書ける。</p>

\[L(\mathbf{A}) = L_{CE}(\sigma(\mathbf{t}(\mathbf{A}))\]

<p>従って、これを$\mathbf{A}$の要素の一つである$A_{ij}$で微分したなら、その値は</p>

\[\frac{\partial L}{\partial A_{ij}} = \left( \frac{\partial{L_{CE}}}{\partial \tilde{\mathbf{y}}} \cdot \frac{\partial \tilde{\mathbf{y}}}{\partial \mathbf{t}} \cdot \frac{\partial \mathbf{t}}{\partial \mathbf{A}} \right)_{ij}\]

<p>のような表現で表せるはずである。実際、上式に現れる偏導関数はそれぞれ以下のように書ける。</p>

\[\begin{aligned}
    \left( \frac{\partial L_{CE}}{\partial \tilde{\mathbf{y}}} \right)_i &amp;= -\frac{y_i}{\tilde{y}_i} \\
    \left( \frac{\partial \tilde{\mathbf{y}}}{\partial \mathbf{t}} \right)_{ij} &amp;= \delta_{ij} \tilde{y}_i - \tilde{y}_i \tilde{y}_j \\
    \left( \frac{\partial \mathbf{t}}{\partial \mathbf{A}} \right)_{ijk} &amp;= \frac{\partial t_k}{\partial a_{ij}} = \delta_{ik} x_j
\end{aligned}\]

<p>もちろん $\mathbf{b}$ に対しても同様に計算が可能だ。一番下の式だけを示せば十分だろう。</p>

\[\left( \frac{\partial \mathbf{t}}{\partial \mathbf{b}} \right)_{ij} = 1\]

<p>これらの式を使うことで、実際にパラメータである$\mathbf{A}$と$\mathbf{b}$に関する損失関数の勾配が計算できたら、もっとも単純には最急降下法を用いて、</p>

\[\begin{aligned}
    A_{ij}^{t+1} &amp;= A_{ij}^t + \alpha \frac{\partial L}{\partial A_{ij}} \\
    b_{i}^{t+1} &amp;= b_i^t + \alpha \frac{\partial L}{\partial b_i}
\end{aligned}\]

<p>のようにして値を更新していけば良い。なお$\alpha$は最急降下法のステップ幅である。</p>

<h2 id="ロジスティック回帰の実装">ロジスティック回帰の実装</h2>


</div>



      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script src='/cpp-python-beginners/public/js/script.js'></script>
  </body>
</html>
